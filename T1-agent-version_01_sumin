"""
=============================================================================
Task 1: Static Zero-Shot 실험
=============================================================================
목적: LLM의 사전학습 지식만으로는 시간에 따른 여론 변화를 반영하지 못함을 증명

참고 자료:
- ESA Essential Facts 2024: https://www.theesa.com/wp-content/uploads/2024/05/Essential-Facts-2024-FINAL.pdf
- Statista Video Game Users by Age 2025
=============================================================================
"""

import openai
import json
import pandas as pd
import numpy as np
from datetime import datetime
import time
import random
from typing import Optional, Dict, Tuple, List
from dataclasses import dataclass

# API Key 설정
client = openai.OpenAI(api_key="api-key 등록해주세요.")

# =============================================================================
# 1. 통계 상수 정의 (Source: ESA 2024, Statista, Newzoo)
# =============================================================================

GENDER_DISTRIBUTION = {
    "Male": 0.54,
    "Female": 0.46
}

AGE_DISTRIBUTION = {
    "18-19": 0.04,
    "20-29": 0.24,
    "30-39": 0.26,
    "40-49": 0.21,
    "50-59": 0.17,
    "60+": 0.08
}

# Newzoo 8 Gamer Personas (2024)
GAMER_TYPE_DISTRIBUTION = {
    "ultimate_gamer": 0.13,
    "all_round_enthusiast": 0.09,
    "cloud_gamer": 0.19,
    "conventional_player": 0.04,
    "hardware_enthusiast": 0.09,
    "popcorn_gamer": 0.13,
    "backseat_gamer": 0.06,
    "time_filler": 0.27
}

# =============================================================================
# 2. Newzoo 기반 상세 게이머 유형 정의
# =============================================================================

GAMER_TYPES = {
    "ultimate_gamer": {
        "type_name": "The Ultimate Gamer",
        "type_name_kr": "얼티밋 게이머",
        "proportion": 0.13,
        "description": "게임에 돈과 시간을 아끼지 않는 열정적인 게이머",
        "traits": {
            "spending_level": "Very High",
            "time_investment": "20+ hours/week",
            "platform_preference": ["PC", "Console"],
            "purchase_timing": "Day-1 구매, 프리오더 활발",
            "information_seeking": "리뷰/평가 상관없이 관심작은 무조건 구매",
            "brand_loyalty": "Very High - 좋아하는 개발사 신작은 무조건 지지"
        },
        "cyberpunk_tendency": "무조건 구매 - CDPR 팬으로서 Day-1 구매 확정",
        "expected_score_range": (75, 95)
    },
    
    "all_round_enthusiast": {
        "type_name": "The All-Round Enthusiast",
        "type_name_kr": "올라운드 열정가",
        "proportion": 0.09,
        "description": "모든 장르를 즐기며 균형 잡힌 게임 생활을 추구",
        "traits": {
            "spending_level": "Medium-High",
            "time_investment": "10-15 hours/week",
            "platform_preference": ["PC", "Console", "Mobile"],
            "purchase_timing": "리뷰 확인 후 1-2주 내 구매",
            "information_seeking": "메타크리틱, 유저 리뷰 꼼꼼히 확인",
            "brand_loyalty": "Medium - 품질이 검증되면 구매"
        },
        "cyberpunk_tendency": "리뷰 보고 구매 결정 - 평가 좋으면 구매",
        "expected_score_range": (50, 80)
    },
    
    "cloud_gamer": {
        "type_name": "The Cloud Gamer",
        "type_name_kr": "클라우드 게이머",
        "proportion": 0.19,
        "description": "고사양 PC 없이 스트리밍/할인 게임 위주로 플레이",
        "traits": {
            "spending_level": "Low-Medium",
            "time_investment": "5-10 hours/week",
            "platform_preference": ["Cloud Gaming", "Budget PC"],
            "purchase_timing": "대폭 할인 시 구매, 최적화 상태 확인 필수",
            "information_seeking": "최적화/성능 관련 리뷰 중점 확인",
            "brand_loyalty": "Low - 가성비와 최적화가 최우선"
        },
        "cyberpunk_tendency": "최적화 나쁘면 절대 안 삼 - 성능 이슈 민감",
        "expected_score_range": (20, 60)
    },
    
    "conventional_player": {
        "type_name": "The Conventional Player",
        "type_name_kr": "전통적 플레이어",
        "proportion": 0.04,
        "description": "익숙한 게임만 반복 플레이, 신작에 관심 없음",
        "traits": {
            "spending_level": "Very Low",
            "time_investment": "5-10 hours/week (같은 게임)",
            "platform_preference": ["PC", "Console"],
            "purchase_timing": "거의 구매 안 함",
            "information_seeking": "신작 정보에 무관심",
            "brand_loyalty": "N/A - 기존 게임만 플레이"
        },
        "cyberpunk_tendency": "신작에 관심 없음 - 기존 즐기던 게임 계속 플레이",
        "expected_score_range": (10, 30)
    },
    
    "hardware_enthusiast": {
        "type_name": "The Hardware Enthusiast",
        "type_name_kr": "하드웨어 열정가",
        "proportion": 0.09,
        "description": "최신 장비와 그래픽에 집착, 벤치마크용 게임 구매",
        "traits": {
            "spending_level": "Very High (하드웨어 + 게임)",
            "time_investment": "15+ hours/week",
            "platform_preference": ["High-End PC"],
            "purchase_timing": "그래픽 쇼케이스 게임은 Day-1 구매",
            "information_seeking": "벤치마크, 그래픽 분석 영상 중점",
            "brand_loyalty": "Medium - 기술력 있는 개발사 선호"
        },
        "cyberpunk_tendency": "그래픽 보러 구매 - RTX/레이트레이싱 테스트용",
        "expected_score_range": (65, 90)
    },
    
    "popcorn_gamer": {
        "type_name": "The Popcorn Gamer",
        "type_name_kr": "팝콘 게이머",
        "proportion": 0.13,
        "description": "직접 플레이보다 Twitch/YouTube 시청을 더 즐김",
        "traits": {
            "spending_level": "Very Low",
            "time_investment": "20+ hours/week (시청)",
            "platform_preference": ["Twitch", "YouTube"],
            "purchase_timing": "거의 구매 안 함",
            "information_seeking": "스트리머/유튜버 플레이 영상으로 대리만족",
            "brand_loyalty": "N/A - 구매보다 시청 선호"
        },
        "cyberpunk_tendency": "인방 보고 대리만족 - 직접 구매 의향 낮음",
        "expected_score_range": (15, 40)
    },
    
    "backseat_gamer": {
        "type_name": "The Backseat Gamer",
        "type_name_kr": "백시트 게이머",
        "proportion": 0.06,
        "description": "과거에는 열심히 했으나 지금은 영상만 봄",
        "traits": {
            "spending_level": "Very Low",
            "time_investment": "5-10 hours/week (시청)",
            "platform_preference": ["YouTube", "과거 즐기던 플랫폼"],
            "purchase_timing": "구매 안 함",
            "information_seeking": "향수 자극하는 콘텐츠 선호",
            "brand_loyalty": "과거 좋아했던 프랜차이즈에만 관심"
        },
        "cyberpunk_tendency": "안삼 - 게임 플레이 자체를 안 함",
        "expected_score_range": (5, 25)
    },
    
    "time_filler": {
        "type_name": "The Time Filler",
        "type_name_kr": "타임 필러",
        "proportion": 0.27,
        "description": "출퇴근/자투리 시간에 모바일 게임만 플레이",
        "traits": {
            "spending_level": "Low (모바일 과금 위주)",
            "time_investment": "10-15 hours/week (모바일)",
            "platform_preference": ["Mobile"],
            "purchase_timing": "콘솔/PC 게임 구매 안 함",
            "information_seeking": "모바일 게임 정보만 관심",
            "brand_loyalty": "N/A - AAA 게임에 무관심"
        },
        "cyberpunk_tendency": "콘솔 대작 절대 안 삼 - 모바일만 플레이",
        "expected_score_range": (0, 20)
    }
}

# =============================================================================
# 3. 한국식 이름 생성기
# =============================================================================

KOREAN_SURNAMES = ["김", "이", "박", "최", "정", "강", "조", "윤", "장", "임"]
KOREAN_MALE_NAMES = ["민수", "준혁", "성민", "현우", "지훈", "동현", "승우", "재현", "태윤", "시우"]
KOREAN_FEMALE_NAMES = ["지은", "수빈", "민지", "서연", "유진", "하은", "예린", "소희", "채원", "다인"]

OCCUPATIONS_BY_AGE = {
    "18-19": ["대학생", "고3 수험생", "재수생", "취준생"],
    "20-29": ["대학생", "대학원생", "신입사원", "스타트업 개발자", "프리랜서", "유튜버"],
    "30-39": ["IT 대기업 과장", "스타트업 CTO", "프리랜서 디자이너", "마케터", "회계사", "변호사"],
    "40-49": ["부장급 직장인", "자영업자", "중소기업 대표", "전업주부", "공무원"],
    "50-59": ["임원급 직장인", "자영업자", "은퇴 준비 중", "전업주부"],
    "60+": ["은퇴자", "자영업자", "전업주부"]
}

def generate_korean_name(gender: str) -> str:
    surname = random.choice(KOREAN_SURNAMES)
    if gender == "Male":
        given_name = random.choice(KOREAN_MALE_NAMES)
    else:
        given_name = random.choice(KOREAN_FEMALE_NAMES)
    return surname + given_name

def sample_age() -> Tuple[str, int]:
    """연령대와 구체적 나이 샘플링"""
    age_group = random.choices(
        list(AGE_DISTRIBUTION.keys()),
        weights=list(AGE_DISTRIBUTION.values())
    )[0]
    
    age_ranges = {
        "18-19": (18, 19),
        "20-29": (20, 29),
        "30-39": (30, 39),
        "40-49": (40, 49),
        "50-59": (50, 59),
        "60+": (60, 70)
    }
    
    min_age, max_age = age_ranges[age_group]
    specific_age = random.randint(min_age, max_age)
    
    return age_group, specific_age

def sample_gender() -> str:
    return random.choices(
        list(GENDER_DISTRIBUTION.keys()),
        weights=list(GENDER_DISTRIBUTION.values())
    )[0]

def sample_gamer_type() -> str:
    return random.choices(
        list(GAMER_TYPE_DISTRIBUTION.keys()),
        weights=list(GAMER_TYPE_DISTRIBUTION.values())
    )[0]

# =============================================================================
# 4. 페르소나 생성기
# =============================================================================

@dataclass
class Persona:
    """게이머 페르소나 데이터 클래스"""
    id: str
    name: str
    gender: str
    age: int
    age_group: str
    occupation: str
    gamer_type: str
    gamer_type_name: str
    gamer_type_name_kr: str
    traits: Dict
    cyberpunk_tendency: str
    expected_score_range: Tuple[int, int]

def generate_persona(persona_id: str, gamer_type: Optional[str] = None) -> Persona:
    """통계 기반 페르소나 생성"""
    
    # 샘플링
    gender = sample_gender()
    age_group, age = sample_age()
    
    if gamer_type is None:
        gamer_type = sample_gamer_type()
    
    gamer_info = GAMER_TYPES[gamer_type]
    
    # 이름 및 직업 생성
    name = generate_korean_name(gender)
    occupation = random.choice(OCCUPATIONS_BY_AGE[age_group])
    
    return Persona(
        id=persona_id,
        name=name,
        gender=gender,
        age=age,
        age_group=age_group,
        occupation=occupation,
        gamer_type=gamer_type,
        gamer_type_name=gamer_info["type_name"],
        gamer_type_name_kr=gamer_info["type_name_kr"],
        traits=gamer_info["traits"],
        cyberpunk_tendency=gamer_info["cyberpunk_tendency"],
        expected_score_range=gamer_info["expected_score_range"]
    )

def generate_balanced_personas(n_per_type: int = 2) -> List[Persona]:
    """각 게이머 유형별로 동일한 수의 페르소나 생성"""
    personas = []
    
    for gamer_type in GAMER_TYPES.keys():
        for i in range(n_per_type):
            persona_id = f"{gamer_type}_{i+1}"
            persona = generate_persona(persona_id, gamer_type=gamer_type)
            personas.append(persona)
    
    return personas

def generate_proportional_personas(total_n: int = 100) -> List[Persona]:
    """실제 분포 비율에 맞게 페르소나 생성"""
    personas = []
    
    for gamer_type, proportion in GAMER_TYPE_DISTRIBUTION.items():
        n_personas = max(1, int(total_n * proportion))
        for i in range(n_personas):
            persona_id = f"{gamer_type}_{i+1}"
            persona = generate_persona(persona_id, gamer_type=gamer_type)
            personas.append(persona)
    
    return personas

# =============================================================================
# 5. 프롬프트 생성
# =============================================================================

def build_persona_prompt(persona: Persona) -> str:
    """페르소나 설명 프롬프트 생성"""
    
    gender_kr = "남성" if persona.gender == "Male" else "여성"
    
    return f"""당신은 {persona.age}세 {gender_kr} '{persona.name}'입니다.
직업: {persona.occupation}

[게이머 유형: {persona.gamer_type_name_kr} ({persona.gamer_type_name})]
{GAMER_TYPES[persona.gamer_type]['description']}

[게임 소비 특성]
- 지출 수준: {persona.traits['spending_level']}
- 주간 게임 시간: {persona.traits['time_investment']}
- 선호 플랫폼: {', '.join(persona.traits['platform_preference'])}
- 구매 타이밍: {persona.traits['purchase_timing']}
- 정보 탐색 방식: {persona.traits['information_seeking']}
- 브랜드 충성도: {persona.traits['brand_loyalty']}"""


def create_static_zeroshot_prompt(persona: Persona, target_date: Optional[str] = None, event_context: Optional[str] = None) -> Tuple[str, str]:
    """Static Zero-Shot 프롬프트 생성"""
    
    persona_desc = build_persona_prompt(persona)
    
    if target_date and event_context:
        # 실험 B: 시점 정보 주입
        system_prompt = f"""[ROLE]
{persona_desc}

[TEMPORAL CONTEXT - 중요]
현재 날짜: {target_date}
상황: {event_context}

당신은 지금 {target_date}을 살고 있습니다.
이 날짜 이후의 사건(패치, DLC, 애니메이션 등)은 아직 일어나지 않았으므로 알 수 없습니다.
오직 {target_date} 이전에 공개된 정보만 알고 있다고 가정하세요.

[INSTRUCTION]
'사이버펑크 2077'에 대한 현재(={target_date}) 시점의 평가를 해주세요.
당신의 게이머 유형 특성과 현재 시점의 상황을 고려하여 판단하세요.

[OUTPUT FORMAT]
반드시 아래 JSON 형식으로만 응답하세요.
{{
    "score": (0~100 정수, 100=강력 추천/구매 의향 최고),
    "sentiment": ("Very Positive", "Positive", "Neutral", "Negative", "Very Negative" 중 하나),
    "purchase_intention": ("즉시 구매", "고려 중", "할인 시 구매", "구매 보류", "구매 안함" 중 하나),
    "reasoning": "2~3문장으로 판단 근거 설명"
}}"""
        user_prompt = f"지금이 {target_date}이야. 사이버펑크 2077 살 만해? 네 유형의 게이머로서 솔직하게 평가해줘."
    
    else:
        # 실험 A: 시점 정보 없음
        system_prompt = f"""[ROLE]
{persona_desc}

[INSTRUCTION]
당신은 위 프로필을 가진 게이머입니다.
질문에 대해 당신의 게이머 유형 특성을 바탕으로 솔직하게 답변하세요.
외부 검색 없이 당신이 알고 있는 정보만으로 판단하세요.

[OUTPUT FORMAT]
반드시 아래 JSON 형식으로만 응답하세요.
{{
    "score": (0~100 정수, 100=강력 추천/구매 의향 최고),
    "sentiment": ("Very Positive", "Positive", "Neutral", "Negative", "Very Negative" 중 하나),
    "purchase_intention": ("즉시 구매", "고려 중", "할인 시 구매", "구매 보류", "구매 안함" 중 하나),
    "reasoning": "2~3문장으로 판단 근거 설명"
}}"""
        user_prompt = "사이버펑크 2077 살 만해? 네 유형의 게이머로서 솔직하게 평가해줘."
    
    return system_prompt, user_prompt

# =============================================================================
# 6. 실험 타임라인
# =============================================================================

TIMELINE = [
    {
        "id": "P0", 
        "date": "2020-11-15", 
        "event": "출시 직전 - 기대감 최고조",
        "expected_sentiment": "Very Positive",
    },
    {
        "id": "P1", 
        "date": "2020-12-20", 
        "event": "출시 직후 - 버그/크래시 대량 발생",
        "expected_sentiment": "Very Negative",
    },
    {
        "id": "P2", 
        "date": "2021-06-01", 
        "event": "핫픽스 연속 배포 중",
        "expected_sentiment": "Neutral",
    },
    {
        "id": "P3", 
        "date": "2022-03-15", 
        "event": "Patch 1.5 대규모 업데이트",
        "expected_sentiment": "Positive",
    },
    {
        "id": "P4", 
        "date": "2023-10-01", 
        "event": "Phantom Liberty DLC 출시",
        "expected_sentiment": "Very Positive",
    },
]

# =============================================================================
# 7. API 호출 함수
# =============================================================================

def call_llm(
    system_prompt: str, 
    user_prompt: str, 
    model: str = "gpt-5.2",  # 또는 gpt-5.2
    temperature: float = 1.2
) -> Optional[Dict]:
    """LLM API 호출"""
    try:
        # OpenAI Chat Completions API (가장 안정적)
        response = client.chat.completions.create(
            model=model,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=temperature,
            response_format={"type": "json_object"}
        )
        return json.loads(response.choices[0].message.content)
    except Exception as e:
        print(f"  [ERROR] {e}")
        return None

# =============================================================================
# 8. 실험 실행 함수
# =============================================================================

def run_experiment_a_balanced(n_per_type: int = 2, n_trials: int = 2) -> pd.DataFrame:
    """
    실험 A: 시점 정보 없는 Static Zero-Shot (균형 샘플링)
    - 각 게이머 유형별로 동일한 수의 페르소나
    """
    print("=" * 70)
    print("실험 A: Static Zero-Shot (균형 샘플링, 시점 정보 없음)")
    print(f"설정: {len(GAMER_TYPES)}개 유형 × {n_per_type}명 × {n_trials}회 = 총 {len(GAMER_TYPES) * n_per_type * n_trials}회")
    print("=" * 70)
    
    personas = generate_balanced_personas(n_per_type)
    results = []
    
    for persona in personas:
        print(f"\n[{persona.id}] {persona.name} ({persona.gamer_type_name_kr})")
        system_prompt, user_prompt = create_static_zeroshot_prompt(persona)
        
        for trial in range(n_trials):
            print(f"  Trial {trial + 1}/{n_trials}...", end=" ")
            response = call_llm(system_prompt, user_prompt)
            
            if response:
                score = response.get("score", 0)
                expected_min, expected_max = persona.expected_score_range
                in_range = expected_min <= score <= expected_max
                
                print(f"Score: {score} (예상 범위: {expected_min}-{expected_max}, {'✓' if in_range else '✗'})")
                
                results.append({
                    "experiment": "A_balanced",
                    "persona_id": persona.id,
                    "persona_name": persona.name,
                    "gender": persona.gender,
                    "age": persona.age,
                    "gamer_type": persona.gamer_type,
                    "gamer_type_name": persona.gamer_type_name_kr,
                    "trial": trial + 1,
                    "score": score,
                    "sentiment": response.get("sentiment"),
                    "purchase_intention": response.get("purchase_intention"),
                    "reasoning": response.get("reasoning"),
                    "expected_min": expected_min,
                    "expected_max": expected_max,
                    "in_expected_range": in_range
                })
            time.sleep(1)
    
    return pd.DataFrame(results)


def run_experiment_b_balanced(n_per_type: int = 1, n_trials: int = 1) -> pd.DataFrame:
    """
    실험 B: 시점 정보 주입 Static Zero-Shot (균형 샘플링)
    - 각 시점별로 동일한 페르소나 세트 사용
    """
    print("\n" + "=" * 70)
    print("실험 B: Static Zero-Shot (균형 샘플링, 시점 정보 주입)")
    print(f"설정: {len(GAMER_TYPES)}개 유형 × {n_per_type}명 × {len(TIMELINE)}시점 × {n_trials}회")
    print("=" * 70)
    
    personas = generate_balanced_personas(n_per_type)
    results = []
    
    for period in TIMELINE:
        print(f"\n{'='*50}")
        print(f"Period {period['id']} ({period['date']}): {period['event']}")
        print(f"{'='*50}")
        
        for persona in personas:
            system_prompt, user_prompt = create_static_zeroshot_prompt(
                persona, 
                target_date=period["date"],
                event_context=period["event"]
            )
            
            for trial in range(n_trials):
                print(f"  [{persona.gamer_type_name_kr}] Trial {trial + 1}...", end=" ")
                response = call_llm(system_prompt, user_prompt)
                
                if response:
                    print(f"Score: {response.get('score', 'N/A')}")
                    
                    results.append({
                        "experiment": "B_temporal",
                        "period_id": period["id"],
                        "date": period["date"],
                        "event": period["event"],
                        "persona_id": persona.id,
                        "persona_name": persona.name,
                        "gender": persona.gender,
                        "age": persona.age,
                        "gamer_type": persona.gamer_type,
                        "gamer_type_name": persona.gamer_type_name_kr,
                        "trial": trial + 1,
                        "score": response.get("score"),
                        "sentiment": response.get("sentiment"),
                        "purchase_intention": response.get("purchase_intention"),
                        "reasoning": response.get("reasoning")
                    })
                time.sleep(1)
    
    return pd.DataFrame(results)

# =============================================================================
# 9. 분석 함수
# =============================================================================

def analyze_results(df_a: pd.DataFrame, df_b: pd.DataFrame):
    """결과 분석"""
    print("\n" + "=" * 70)
    print("실험 결과 분석")
    print("=" * 70)
    
    # 실험 A: 게이머 유형별 점수 분포
    print("\n[실험 A: 게이머 유형별 점수 분포]")
    print("-" * 60)
    
    type_stats = df_a.groupby("gamer_type_name").agg({
        "score": ["mean", "std", "min", "max"],
        "in_expected_range": "mean"
    }).round(2)
    type_stats.columns = ["평균", "표준편차", "최소", "최대", "예상범위적중률"]
    print(type_stats)
    
    # 구매 의향 분포
    print("\n[게이머 유형별 구매 의향 분포]")
    purchase_dist = pd.crosstab(
        df_a["gamer_type_name"], 
        df_a["purchase_intention"], 
        normalize="index"
    ).round(2) * 100
    print(purchase_dist)
    
    # 실험 B: 시점별 변화
    if not df_b.empty:
        print("\n\n[실험 B: 시점별 평균 점수]")
        print("-" * 60)
        
        pivot = df_b.pivot_table(
            values="score",
            index="gamer_type_name",
            columns="period_id",
            aggfunc="mean"
        ).round(1)
        print(pivot)
        
        # 전체 시점별 평균
        print("\n[전체 시점별 평균 점수]")
        period_means = df_b.groupby("period_id")["score"].mean().round(1)
        print(period_means)
        
        # 변동성 분석
        print("\n[게이머 유형별 시점간 변동성 (표준편차)]")
        volatility = df_b.groupby("gamer_type_name")["score"].std().round(2)
        print(volatility.sort_values(ascending=False))


def save_results(df_a: pd.DataFrame, df_b: pd.DataFrame, output_dir: str = "."):
    """결과 저장"""
    df_a.to_csv(f"{output_dir}/task1_v2_experiment_a.csv", index=False, encoding="utf-8-sig")
    df_b.to_csv(f"{output_dir}/task1_v2_experiment_b.csv", index=False, encoding="utf-8-sig")
    
    # 요약 테이블
    summary_a = df_a.groupby("gamer_type_name").agg({
        "score": ["mean", "std"],
        "in_expected_range": "mean"
    }).round(2)
    summary_a.to_csv(f"{output_dir}/task1_v2_summary_a.csv", encoding="utf-8-sig")
    
    if not df_b.empty:
        summary_b = df_b.pivot_table(
            values="score",
            index="gamer_type_name",
            columns="period_id",
            aggfunc="mean"
        ).round(1)
        summary_b.to_csv(f"{output_dir}/task1_v2_summary_b.csv", encoding="utf-8-sig")
    
    print(f"\n결과 저장 완료: {output_dir}/task1_v2_*.csv")

# =============================================================================
# 10. 메인 실행
# =============================================================================

if __name__ == "__main__":
    # 시드 고정 (재현성)
    random.seed(42)
    
    print("=" * 70)
    print("Task 1: Static Zero-Shot 실험 (v2 - Newzoo 게이머 유형 기반)")
    print("=" * 70)
    print("\n[게이머 유형 분포]")
    for gtype, info in GAMER_TYPES.items():
        print(f"  {info['type_name_kr']:12} ({info['proportion']*100:4.0f}%): {info['cyberpunk_tendency']}")
    
    # 실험 실행 (API 비용 고려하여 최소 설정)
    print("\n" + "=" * 70)
    
    # 실험 A: 각 유형 2명씩, 2회 반복
    df_a = run_experiment_a_balanced(n_per_type=2, n_trials=2)
    
    # 실험 B: 각 유형 1명씩, 5개 시점, 1회
    df_b = run_experiment_b_balanced(n_per_type=1, n_trials=1)
    
    # 분석 및 저장
    analyze_results(df_a, df_b)
    save_results(df_a, df_b)
    
    # 최종 요약
    print("\n" + "=" * 70)
    print("핵심 결론")
    print("=" * 70)
    
    if not df_a.empty:
        overall_accuracy = df_a["in_expected_range"].mean() * 100
        print(f"\n✓ 예상 범위 적중률: {overall_accuracy:.1f}%")
        
        if overall_accuracy > 70:
            print("→ 게이머 유형별 특성이 점수에 잘 반영됨")
        else:
            print("→ 게이머 유형별 차별화 부족 - 프롬프트 개선 필요")
    
    if not df_b.empty:
        period_std = df_b.groupby("gamer_type_name")["score"].std().mean()
        print(f"\n✓ 시점간 평균 변동성: {period_std:.1f}점")
        
        if period_std < 15:
            print("→ Static Zero-Shot은 시점 정보 주입에도 변동성이 낮음")
            print("→ Time-Aware RAG의 필요성 증명!")
        else:
            print("→ LLM이 사전학습 지식으로 시점 변화를 일부 반영")
            print("→ 이는 'temporal reasoning'이 아닌 'memorization'임을 논문에 명시 필요")
